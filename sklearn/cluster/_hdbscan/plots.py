# -*- coding: utf-8 -*-
# Author: Leland McInnes <leland.mcinnes@gmail.com>
#
# License: BSD 3 clause

import numpy as np

from ._hdbscan_tree import compute_stability, labelling_at_cut, recurse_leaf_dfs

CB_LEFT = 0
CB_RIGHT = 1
CB_BOTTOM = 2
CB_TOP = 3


def _bfs_from_cluster_tree(tree, bfs_root):
    """
    Perform a breadth first search on a tree in condensed tree format
    """

    result = []
    to_process = [bfs_root]

    while to_process:
        result.extend(to_process)
        to_process = tree["child"][np.in1d(tree["parent"], to_process)].tolist()

    return result


def _recurse_leaf_dfs(cluster_tree, current_node):
    children = cluster_tree[cluster_tree["parent"] == current_node]["child"]
    if len(children) == 0:
        return [
            current_node,
        ]
    else:
        return sum([recurse_leaf_dfs(cluster_tree, child) for child in children], [])


def _get_leaves(condensed_tree):
    cluster_tree = condensed_tree[condensed_tree["child_size"] > 1]
    if cluster_tree.shape[0] == 0:
        # Return the only cluster, the root
        return [condensed_tree["parent"].min()]

    root = cluster_tree["parent"].min()
    return _recurse_leaf_dfs(cluster_tree, root)


class CondensedTree(object):
    """The condensed tree structure, which provides a simplified or smoothed version
    of the :class:`~hdbscan.plots.SingleLinkageTree`.

    Parameters
    ----------
    condensed_tree_array : numpy recarray from :class:`~hdbscan.HDBSCAN`
        The raw numpy rec array version of the condensed tree as produced
        internally by hdbscan.

    cluster_selection_method : string, optional (default 'eom')
        The method of selecting clusters. One of 'eom' or 'leaf'

    allow_single_cluster : Boolean, optional (default False)
        Whether to allow the root cluster as the only selected cluster

    """

    def __init__(
        self,
        condensed_tree_array,
        cluster_selection_method="eom",
        allow_single_cluster=False,
    ):
        self._raw_tree = condensed_tree_array
        self.cluster_selection_method = cluster_selection_method
        self.allow_single_cluster = allow_single_cluster

    def get_plot_data(
        self, leaf_separation=1, log_size=False, max_rectangle_per_icicle=20
    ):
        """Generates data for use in plotting the 'icicle plot' or dendrogram
        plot of the condensed tree generated by HDBSCAN.

        Parameters
        ----------
        leaf_separation : float, optional
                          How far apart to space the final leaves of the
                          dendrogram. (default 1)

        log_size : boolean, optional
                   Use log scale for the 'size' of clusters (i.e. number of
                   points in the cluster at a given lambda value).
                   (default False)

        max_rectangles_per_icicle : int, optional
            To simplify the plot this method will only emit
            ``max_rectangles_per_icicle`` bars per branch of the dendrogram.
            This ensures that we don't suffer from massive overplotting in
            cases with a lot of data points.

        Returns
        -------
        plot_data : dict
                    Data associated to bars in a bar plot:
                        `bar_centers` x coordinate centers for bars
                        `bar_tops` heights of bars in lambda scale
                        `bar_bottoms` y coordinate of bottoms of bars
                        `bar_widths` widths of the bars (in x coord scale)
                        `bar_bounds` a 4-tuple of [left, right, bottom, top]
                                     giving the bounds on a full set of
                                     cluster bars
                    Data associates with cluster splits:
                        `line_xs` x coordinates for horizontal dendrogram lines
                        `line_ys` y coordinates for horizontal dendrogram lines
        """
        leaves = _get_leaves(self._raw_tree)
        last_leaf = self._raw_tree["parent"].max()
        root = self._raw_tree["parent"].min()

        # We want to get the x and y coordinates for the start of each cluster
        # Initialize the leaves, since we know where they go, the iterate
        # through everything from the leaves back, setting coords as we go
        if isinstance(leaves, np.int64):
            cluster_x_coords = {leaves: leaf_separation}
        else:
            cluster_x_coords = dict(
                zip(leaves, [leaf_separation * x for x in range(len(leaves))])
            )
        cluster_y_coords = {root: 0.0}

        for cluster in range(last_leaf, root - 1, -1):
            split = self._raw_tree[["child", "lambda_val"]]
            split = split[
                (self._raw_tree["parent"] == cluster)
                & (self._raw_tree["child_size"] > 1)
            ]
            if len(split["child"]) > 1:
                left_child, right_child = split["child"]
                cluster_x_coords[cluster] = np.mean(
                    [cluster_x_coords[left_child], cluster_x_coords[right_child]]
                )
                cluster_y_coords[left_child] = split["lambda_val"][0]
                cluster_y_coords[right_child] = split["lambda_val"][1]

        # We use bars to plot the 'icicles', so we need to generate centers, tops,
        # bottoms and widths for each rectangle. We can go through each cluster
        # and do this for each in turn.
        bar_centers = []
        bar_tops = []
        bar_bottoms = []
        bar_widths = []

        cluster_bounds = {}

        scaling = np.sum(self._raw_tree[self._raw_tree["parent"] == root]["child_size"])

        if log_size:
            scaling = np.log(scaling)

        for c in range(last_leaf, root - 1, -1):

            cluster_bounds[c] = [0, 0, 0, 0]

            c_children = self._raw_tree[self._raw_tree["parent"] == c]
            current_size = np.sum(c_children["child_size"])
            current_lambda = cluster_y_coords[c]
            cluster_max_size = current_size
            cluster_max_lambda = c_children["lambda_val"].max()
            cluster_min_size = np.sum(
                c_children[c_children["lambda_val"] == cluster_max_lambda]["child_size"]
            )

            if log_size:
                current_size = np.log(current_size)
                cluster_max_size = np.log(cluster_max_size)
                cluster_min_size = np.log(cluster_min_size)

            total_size_change = float(cluster_max_size - cluster_min_size)
            step_size_change = total_size_change / max_rectangle_per_icicle

            cluster_bounds[c][CB_LEFT] = cluster_x_coords[c] * scaling - (
                current_size / 2.0
            )
            cluster_bounds[c][CB_RIGHT] = cluster_x_coords[c] * scaling + (
                current_size / 2.0
            )
            cluster_bounds[c][CB_BOTTOM] = cluster_y_coords[c]
            cluster_bounds[c][CB_TOP] = np.max(c_children["lambda_val"])

            last_step_size = current_size
            last_step_lambda = current_lambda

            for i in np.argsort(c_children["lambda_val"]):
                row = c_children[i]
                if row["lambda_val"] != current_lambda and (
                    last_step_size - current_size > step_size_change
                    or row["lambda_val"] == cluster_max_lambda
                ):
                    bar_centers.append(cluster_x_coords[c] * scaling)
                    bar_tops.append(row["lambda_val"] - last_step_lambda)
                    bar_bottoms.append(last_step_lambda)
                    bar_widths.append(last_step_size)
                    last_step_size = current_size
                    last_step_lambda = current_lambda
                if log_size:
                    exp_size = np.exp(current_size) - row["child_size"]
                    # Ensure we don't try to take log of zero
                    if exp_size > 0.01:
                        current_size = np.log(np.exp(current_size) - row["child_size"])
                    else:
                        current_size = 0.0
                else:
                    current_size -= row["child_size"]
                current_lambda = row["lambda_val"]

        # Finally we need the horizontal lines that occur at cluster splits.
        line_xs = []
        line_ys = []

        for row in self._raw_tree[self._raw_tree["child_size"] > 1]:
            parent = row["parent"]
            child = row["child"]
            child_size = row["child_size"]
            if log_size:
                child_size = np.log(child_size)
            sign = np.sign(cluster_x_coords[child] - cluster_x_coords[parent])
            line_xs.append(
                [
                    cluster_x_coords[parent] * scaling,
                    cluster_x_coords[child] * scaling + sign * (child_size / 2.0),
                ]
            )
            line_ys.append([cluster_y_coords[child], cluster_y_coords[child]])

        return {
            "bar_centers": bar_centers,
            "bar_tops": bar_tops,
            "bar_bottoms": bar_bottoms,
            "bar_widths": bar_widths,
            "line_xs": line_xs,
            "line_ys": line_ys,
            "cluster_bounds": cluster_bounds,
        }

    def _select_clusters(self):
        if self.cluster_selection_method == "eom":
            stability = compute_stability(self._raw_tree)
            if self.allow_single_cluster:
                node_list = sorted(stability.keys(), reverse=True)
            else:
                node_list = sorted(stability.keys(), reverse=True)[:-1]
            cluster_tree = self._raw_tree[self._raw_tree["child_size"] > 1]
            is_cluster = {cluster: True for cluster in node_list}

            for node in node_list:
                child_selection = cluster_tree["parent"] == node
                subtree_stability = np.sum(
                    [
                        stability[child]
                        for child in cluster_tree["child"][child_selection]
                    ]
                )

                if subtree_stability > stability[node]:
                    is_cluster[node] = False
                    stability[node] = subtree_stability
                else:
                    for sub_node in _bfs_from_cluster_tree(cluster_tree, node):
                        if sub_node != node:
                            is_cluster[sub_node] = False

            return sorted([cluster for cluster in is_cluster if is_cluster[cluster]])

        elif self.cluster_selection_method == "leaf":
            return _get_leaves(self._raw_tree)
        else:
            raise ValueError(
                "Invalid Cluster Selection Method: %s\n"
                'Should be one of: "eom", "leaf"\n'
            )

    def to_numpy(self):
        """Return a numpy structured array representation of the condensed tree."""
        return self._raw_tree.copy()


def _get_dendrogram_ordering(parent, linkage, root):

    if parent < root:
        return []

    return (
        _get_dendrogram_ordering(int(linkage[parent - root][0]), linkage, root)
        + _get_dendrogram_ordering(int(linkage[parent - root][1]), linkage, root)
        + [parent]
    )


def _calculate_linewidths(ordering, linkage, root):

    linewidths = []

    for x in ordering:
        if linkage[x - root][0] >= root:
            left_width = linkage[int(linkage[x - root][0]) - root][3]
        else:
            left_width = 1

        if linkage[x - root][1] >= root:
            right_width = linkage[int(linkage[x - root][1]) - root][3]
        else:
            right_width = 1

        linewidths.append((left_width, right_width))

    return linewidths


class SingleLinkageTree(object):
    """A single linkage format dendrogram tree, with plotting functionality
    and networkX support.

    Parameters
    ----------
    linkage : ndarray (n_samples, 4)
        The numpy array that holds the tree structure. As output by
        scipy.cluster.hierarchy, hdbscan, of fastcluster.

    """

    def __init__(self, linkage):
        self._linkage = linkage

    def to_numpy(self):
        """Return a numpy array representation of the single linkage tree.

        This representation conforms to the scipy.cluster.hierarchy notion
        of a single linkage tree, and can be used with all the associated
        scipy tools. Please see the scipy documentation for more details
        on the format.
        """
        return self._linkage.copy()

    def get_clusters(self, cut_distance, min_cluster_size=5):
        """Return a flat clustering from the single linkage hierarchy.

        This represents the result of selecting a cut value for robust single linkage
        clustering. The `min_cluster_size` allows the flat clustering to declare noise
        points (and cluster smaller than `min_cluster_size`).

        Parameters
        ----------

        cut_distance : float
            The mutual reachability distance cut value to use to generate a
            flat clustering.

        min_cluster_size : int, optional
            Clusters smaller than this value with be called 'noise' and remain
            unclustered in the resulting flat clustering.

        Returns
        -------

        labels : array [n_samples]
            An array of cluster labels, one per datapoint. Unclustered points
            are assigned the label -1.
        """
        return labelling_at_cut(self._linkage, cut_distance, min_cluster_size)


class MinimumSpanningTree(object):
    def __init__(self, mst, data):
        self._mst = mst
        self._data = data

    def to_numpy(self):
        """Return a numpy array of weighted edges in the minimum spanning tree"""
        return self._mst.copy()
